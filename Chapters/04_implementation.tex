\section{Implementation} \label{s:implementation}

In this chapter we will describe how we implemented several features of the Rust type system in Statix. First, we shortly focus on the regular typing of variables and expressions. In the second part we will explain how we implemented several substructural/linear type system features.

\subsection{Scoping and Name resolution}

One of the most rudimentary features of a type system is name resolution. Without proper name resolution, it is not possible to determine the type of variables, with makes proper type checking impossible.

As we have seen in \autoref{s:statix}, name resolution in Statix is done by adding declarations in a scope graph, which can be queried in subscopes. We implemented it in this way, without the usage of any advanced features (like using different labels or namespaces). 
To prevent forward name resolution we decided to use a scope for every statement, rather than following the lexical scope.

\subsection{Regular typing} \label{sec:regular-typing}

The basis of the Rust type system are types as they are occurring in many statically-typed languages. As such, we created rules \code{typeOfExpr} that give every expression its appropriate type. As primary types, \code{BOOL()}, \code{NUM()} and \code{UNIT()}, are available. Regarding numeric types, we choose to not exactly resemble the Rust type system with respect to sizes and signs (i.e. having \code{i8}, \code{u64} etc.), but have only one type: \code{NUM()}. Having multiple numeric types would come with a lot of inference rules and type coercion, which is out of scope for this project.

For each variable, we annotated the scope graph with \code{type: occurrence -> DataType} relations, which can be queried from subscopes.

\subsubsection{Struct types} \label{sec:struct-type}

For struct types, we implemented a special type, having a scope parameter (\code{STRUCT: scope -> DataType}). In this scope, fields are declared. When type-checking a field access, the scope of the struct for which a field is accessed can be (recursively) found and queried.

\subsubsection{Functions}

Functions are implemented straightforward as well. Every function has as its type a list of input types, and an output type. Since in Rust, it is possible to assign a function reference to a variable, we chose to have them in the same namespace \code{Var}.

\subsubsection{Mutable types}

In Rust, variables can be either mutable or immutable. We have thought of three different ways to encode this mutability:
\begin{enumerate}
    \item Have a \code{Mut()}/\code{Immut()} parameter on each type
    \item Add a type \code{VarType: Mutability * DataType}, to be able to annotate mutability on a \code{DataType}
    \item Add a separate type \code{MUT: DataType -> DataType}
\end{enumerate}

Obviously, the first option would lead to a lot of unnecessary code duplication, verbosity and clutter, since at many places, the mutability can not be determined accurately, or simply is not relevant. Many expressions can be applied on (a mix of) mutable and immutable values, and then mutability is not important.

The second option would solve a many of these problems. By assigning expressions a \code{DataType}, and variables a \code{VarType}. 
% DOMINIQUE: Deze hebben we geprobeerd, maar niet gedaan. Weet je nog waarom????

Eventually, we went for the third options, since it gave the most flexibility on when to use mutability, and when not to. Possible coercions from mutable to immutable types are implemented by applying the rule \code{stripMut}.

\subsubsection{References}

In order to implement a borrow checker, having reference types is important. We thought if 2 ways to implement references:
\begin{enumerate}
    \item Have 2 additional types: \\ 
    \code{MutRef: DataType -> DataType} and\\ \code{ImmutRef: DataType -> DataType}
    \item Have 1 additional type:
    \\ \code{REF: Mutability * DataType -> DataType}
\end{enumerate}

The first important thing to note here is that variable mutability is not the same as reference mutability. Variable mutability means that a variable (or a field, in case of a struct) can be reassigned.

Both ways are equivalent in expressiveness and verboseness. We choose the second options, since it made it easier for us to handle cases where mutability is not important. In that case, we could simply match on a wildcard (\code{_}), instead of writing 2 separate rules.

\subsection{Advanced type system features}

In this section we will describe our implementation of the more advanced type system features we touched on: move checking and borrow checking.

\subsubsection{Move checking}

The first type system feature we will discuss is move checking. To quickly recall the basics from section XX:
\begin{itemize}
    \item "Moving" is assigning a variable or field with a type that does not implement the \code{Copy} trait to another variable or field.
    \item Move checking is checking that each variable or field is moved at most once.
\end{itemize}

\paragraph{Design choices}

In this subsection, we discuss the most fundamental design choices for this feature.

Firstly, we implemented the \code{Copy} trait by defining a relation:\ \code{copy:}\\\code{DataType -> Copyable}, where the sort \code{Copyable} has 2 constructors: \code{COPY()} and \code{NOCOPY()}. We decided to use a dedicated relation because we did not implement trait implementation in our type system. For all existing types, this relation is declared in the root scope, so that it can be queried from any scope.

Secondly (and contrary to borrow checking, as we will see), it is important to note that moving occurs on \textit{control-flow graph} level. Once a value is moved, it will stay moved, even when the inner scope in which this move might occur ends. Therefore, we decided to build a control-flow graph, in addition to the scope graph.

While it would technically be possible to have one big scope and control-flow graph, with labels distinguishing scope and control-flow edges, we decided not to do so, but instead implement 2 distinguished graphs. We think combining the graphs makes maintaining the graph more complex, while it does not add value, since no query requires information from both graphs.

Thirdly, only assignment operations that have a variable as source, and passing a variable as parameter to a function can violate move rules. The Rust typing rules ensure that any other owned expression can not be references from another place, and therefore can not be moved twice. For example: in the snippet \code{let v = foo().a}, the return value of \code{foo()} must be owned, and the owning rules we are implementing guarantee that no other variable will reference that value. As far as we are aware, this holds for every language construct. 

\paragraph{Basic move implementation}

Whenever a variable is moved (which is in the language patterns \\ \code{Assign(_, p@Path(_))}, \code{LetInit(_, p@Path(_))} and \code{FieldInit(_, p@Path(_)}), we add an relation \code{move(p)} in the control flow graph node of the operation. For any use of a variable (including moves, but other uses, like field access, borrows and argument passing, as well) we query its parent node for other \code{move(p)} instances. If any of those exists, we raise an error, since then the variable has already been moved.

\paragraph{Field moves}

Moves from struct fields to other targets have somewhat more difficult semantics. When a field of a struct is moved, its subfields may not be moved anymore, since they are already moved with the initial field. Moreover, all superfields may not be moved anymore because that would move the first field once more. 

We implemented this type system feature similar to regular moves. Whenever a field is moved, we add a\\ \code{fieldMove(var, fields)} to its control-flow graph node. On every field usage, we query all parent scopes for usage of fields of the same variable, and check if those fields are not a sub- or superfield of the used field.

