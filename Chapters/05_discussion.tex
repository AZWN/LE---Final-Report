\section{Discussion}\label{s:discussion}

%%%%%%
% Ik zou discussion, future work en conclusie 1 section maken
%%%%%%

In this section, we will reflect on the implementation of the Rust typesystem.

\subsection{Coverage}

In this section, we will describe the features of the type system we have and have not covered. We will also assess if implementing these features would, on a conceptual level, be different from the features we have.

\subsubsection{Regular types}

Regarding the regular, nominal type system, we have not convered the following features:

\begin{itemize}
	\item Parameterized types
	\item Tuples
	\item Enums
	\item Traits
	\item Arrays and slices
	\item Numeric coercions
\end{itemize}

\paragraph{Parameterized types}

Rust offers a very rich type system for parameterized types. Any struct, enum or trait can have an arbitrary number of type parameters, and over each of these parameters constraints can be defined. See for example:

\begin{lstlisting}[language=rust, showstringspaces=false, escapechar=~, label={lst:param_constraints}, caption={Example of complex parametric constraints}]
trait ConvertTo<Output> {
    fn convert(&self) -> Output;
}

trait Double<T1: ConvertTo<i32>, T2> 
  where ConvertTo<T2> : Copy
{
  fn foo(t1: T1, t2: ConvertTo<T2>);
}

struct Bar<'a, A> where A: 'a {
    a : &'a A
}
\end{lstlisting}

When statix was published\cite{antwerpen}, a sample implementing a parametric type system for Featherweight Generic Java (FGJ) was given \cite{statix_reference_impl}, proving that statix is powerful enough to implement such type systems. COMPARE THIS TS TO RUST? MISSING FEATURES?

\paragraph{Tuples}

In fact, tuples, and matching expressions on them can be desugared to regular structs, where each component has its index as field name. For example \code{(1, true)} would be desugared to\\ \code{Tuple2<i32, bool> { 0: 1, 1: true} $\}$. This allows accessing tuple members by their index (e.g. \code{tuple.0}, which is valid syntax in Rust.

Therefore, we think that adding tuples to the existing type system will be well doable, and would not given better insight in either Rust or Statix.

\paragraph{Enums}

% Move checking in enums/ref keyword

\paragraph{Traits}

\paragraph{Arrays and slices}

\paragraph{Numeric coercions}

As we mentioned in \autoref{sec:regular-typing}, we implemented just one numeric type: \code{NUM()}. This could be extended...

\subsubsection{Move checking}

% Reassigning moved struct var

\subsubsection{Borrow checking}

% Returning references to upper scopes
% Borrow checking with lifetime parameters in structs/functions

\subsection{Future Work}\label{s:future_work}
